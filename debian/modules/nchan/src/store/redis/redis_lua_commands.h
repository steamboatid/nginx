#ifndef NCHAN_REDIS_LUA_SCRIPTS_H
#define NCHAN_REDIS_LUA_SCRIPTS_H
// don't edit this please, it was auto-generated by hsss
// https://github.com/slact/hsss

typedef struct {
  char *name;
  char *hash;
  char *script;
} redis_lua_script_t;

typedef struct {
  //input:  keys: [], values: [namespace, channel_id, number, time, nginx_worker_id]
  //output: -none-
  redis_lua_script_t add_fakesub;

  //input:  keys: [], values: [namespace, channel_id, ttl_msec, ttl_safety_margin_msec]
  // ttl_msec is for when there are no messages but at least 1 subscriber.
  //output: seconds until next keepalive is expected, or -1 for "let it disappear"
  redis_lua_script_t channel_keepalive;

  //input: keys: [],  values: [ namespace, channel_id, publish_command, use_accurate_subscriber_count ]
  //output: channel_hash {ttl, time_last_seen, subscribers, messages} or nil
  // delete this channel and all its messages
  redis_lua_script_t delete;

  //input: keys: [],  values: [ namespace, channel_id, use_accurate_subscriber_count ]
  //output: channel_hash {ttl, time_last_seen, subscribers, last_channel_id, messages} or nil
  // finds and return the info hash of a channel, or nil of channel not found
  redis_lua_script_t find_channel;

  //input:  keys: [], values: [namespace, channel_id, msg_time, msg_tag, no_msgid_order, create_channel_ttl]
  //output: result_code, msg_ttl, msg_time, msg_tag, prev_msg_time, prev_msg_tag, message, content_type, eventsource_event, compression_type, channel_subscriber_count
  // no_msgid_order: 'FILO' for oldest message, 'FIFO' for most recent
  // create_channel_ttl - make new channel if it's absent, with ttl set to this. 0 to disable.
  // result_code can be: 200 - ok, 404 - not found, 410 - gone, 418 - not yet available
  redis_lua_script_t get_message;

  //input:  keys: [message_key], values: []
  //output: msg_ttl, msg_time, msg_tag, prev_msg_time, prev_msg_tag, message, content_type, eventsource_event, compression, channel_subscriber_count
  redis_lua_script_t get_message_from_key;

  //input:  keys: [unique_request_id_key], values: []
  //output: next_unique_request_id_integer
  redis_lua_script_t get_subscriber_info_id;

  //input: keys: [],  values: [ namespace, channel_id, use_accurate_subscriber_count ]
  //output: {subscribers_count, last_subscriber_seed}, or nil of channel not found
  redis_lua_script_t nostore_publish_multiexec_channel_info;

  //input:  keys: [], values: [namespace, channel_id, message, content_type, eventsource_event, compression_setting, msg_ttl, max_msg_buf_size, pubsub_msgpacked_size_cutoff, publish_command, use_accurate_subscriber_count]
  //output: channel_hash {ttl, time_last_subscriber_seen, subscribers, last_message_id, messages}, channel_created_just_now?
  redis_lua_script_t publish;

  //input: keys: [],  values: [ namespace, channel_id, info_response_id ]
  //output: -nothing-
  redis_lua_script_t request_subscriber_info;

  //redis-store consistency check
  redis_lua_script_t rsck;

  //input: keys: [], values: [namespace, channel_id, subscriber_id, active_ttl_msec, ttl_safety_margin_msec, time, want_channel_settings]
  //  'subscriber_id' can be '-' for new id, or an existing id
  //  'active_ttl_msec' is channel ttl with non-zero subscribers. -1 to persist, >0 ttl in msec
  //  'ttl_safety_margin_msec' is number of seconds before TTL that Nchan issues a keepalive recheck
  //output: subscriber_id, num_current_subscribers, next_keepalive_time, channel_buffer_length
  //  'channel_buffer_length' is returned only if want_channel_settings is 1
  redis_lua_script_t subscriber_register;

  //input: keys: [], values: [namespace, channel_id, subscriber_id, empty_ttl]
  // 'subscriber_id' is an existing id
  // 'empty_ttl' is channel ttl when without subscribers. 0 to delete immediately, -1 to persist, >0 ttl in sec
  //output: subscriber_id, num_current_subscribers
  redis_lua_script_t subscriber_unregister;

} redis_lua_scripts_t;
extern redis_lua_scripts_t redis_lua_scripts;
extern const int redis_lua_scripts_count;
#define REDIS_LUA_SCRIPTS_ALL_HASHES "f3b5cc02b9902e94db37949cf0eba6b3fb30376f 7bfe076302b20eeb2e5b0a325599325c96fabc80 a928e8b91abe4c7be327b4ed79a7e0b4a6a13236 0c5d0e0663393ed714801cbe68940d4c8f81e076 fb9c46d33b3798a11d4eca6e0f7a3f92beba8685 304efcd42590f99e0016686572530defd3de1383 3490d5bc3fdc7ed065d9d54b4a0cb8ad6b62c180 35696def4f2ec62f9b91a72fa17bba7a4e4cb6cf 1c68d9e05fe55e2992a917c41255f23e1330b255 93c500e094dfc5364251854eeac8d4331a0223c0 2fca046fa783d6cc25e493c993c407e59998e6e8 24643f71942769759df94b4ddfea15925612f595 51f4b6919ec97d42f5a9a7a10ee7742579b6a8f4"
#define REDIS_LUA_SCRIPTS_COUNT 13
#define REDIS_LUA_SCRIPTS_EACH(script) \
for((script)=(redis_lua_script_t *)&redis_lua_scripts; (script) < (redis_lua_script_t *)(&redis_lua_scripts + 1); (script)++) 
#endif //NCHAN_REDIS_LUA_SCRIPTS_H
